import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import yfinance as yf
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# È°µÈù¢ÈÖçÁΩÆ
st.set_page_config(
    page_title="AGIX Fund Monitor",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Ëá™ÂÆö‰πâCSSÊ†∑Âºè
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #1f77b4;
    }
    .positive {
        color: #28a745;
    }
    .negative {
        color: #dc3545;
    }
</style>
""", unsafe_allow_html=True)

@st.cache_data
def load_data():
    """Âä†ËΩΩÊâÄÊúâÊï∞ÊçÆÊñá‰ª∂"""
    try:
        # ËÆæÁΩÆpandasÊòæÁ§∫ÈÄâÈ°π
        pd.set_option('display.max_columns', None)
        pd.set_option('display.max_rows', None)
        # Âä†ËΩΩ‰ª∑Ê†ºÊï∞ÊçÆ
        stockprice = pd.read_excel(
            "ciq reference/data/StockPriceValue.xlsx", 
            header=0, 
            index_col=0, 
            sheet_name="Price", 
            parse_dates=['Date']
        )
        
        # Á°Æ‰øùÁ¥¢ÂºïÊòØÊó•ÊúüÁ±ªÂûã
        if stockprice.index.name == 'Date':
            stockprice.index = pd.to_datetime(stockprice.index, errors='coerce')
        
        stockprice = stockprice.replace(0, np.nan)
        filled_pri = stockprice.bfill()
        
        # Á°Æ‰øùÊâÄÊúâÊï∞ÂÄºÂàóÈÉΩÊòØÊï∞ÂÄºÁ±ªÂûã
        for col in filled_pri.columns:
            if filled_pri[col].dtype == 'object':
                filled_pri[col] = pd.to_numeric(filled_pri[col], errors='coerce')
        
        # Âä†ËΩΩÊåÅ‰ªìÊï∞ÊçÆ
        shares = pd.read_excel(
            "ciq reference/data/Shares.xlsx", 
            header=0, 
            index_col=0, 
            sheet_name="shares"
        )
        
        # Á°Æ‰øùÊâÄÊúâÊï∞ÂÄºÂàóÈÉΩÊòØÊï∞ÂÄºÁ±ªÂûã
        for col in shares.columns:
            if shares[col].dtype == 'object':
                shares[col] = pd.to_numeric(shares[col], errors='coerce')
        
        # Âä†ËΩΩÊØèÊó•ÁõëÊéßÊï∞ÊçÆ - Ë∑≥ËøáÂâç3Ë°åÊó†Áî®‰ø°ÊÅØÔºåÂπ∂ËøáÊª§ÊéâÂ∫ïÈÉ®ÁöÑÊó•ÊúüË°å
        daily_monitor = pd.read_excel(
            "ciq reference/data/ÊØèÊó•Êï∞ÊçÆÁõëÊéß.xlsx",
            sheet_name="chart",
            header=0,  # Á¨¨1Ë°å‰Ωú‰∏∫ÂàóÊ†áÈ¢ò
            skiprows=[1, 2],  # Ë∑≥ËøáÁ¨¨2-3Ë°åÊó†Áî®‰ø°ÊÅØ
            index_col=0,
            parse_dates=True
        )
        
        # Âä†ËΩΩraw1Ë°®Êï∞ÊçÆ - A1:I9ËåÉÂõ¥
        try:
            raw1_data = pd.read_excel(
                "ciq reference/data/ÊØèÊó•Êï∞ÊçÆÁõëÊéß.xlsx",
                sheet_name="raw1",
                header=0,  # Á¨¨1Ë°å‰Ωú‰∏∫ÂàóÂêç
                usecols="A:I",  # Âè™ËØªÂèñA-IÂàó
                nrows=9  # Âè™ËØªÂèñÂâç9Ë°å
            )
            
            # ËøáÊª§ÊéâNameÊòØ"Heng Sheng Tech Index"ÁöÑË°å
            if 'Name' in raw1_data.columns:
                raw1_data = raw1_data[raw1_data['Name'] != 'Heng Sheng Tech Index']
            
            # ËøáÊª§ÊéâNameÊòØ"Nasdaq"ÊàñÂåÖÂê´"Nasdaq"ÁöÑË°å
            if 'Name' in raw1_data.columns:
                raw1_data = raw1_data[~raw1_data['Name'].str.contains('Nasdaq', case=False, na=False)]
            
            # Âà†Èô§TickerÂàó
            if 'Ticker' in raw1_data.columns:
                raw1_data = raw1_data.drop(columns=['Ticker'])
            
        except Exception as e:
            st.warning(f"Êó†Ê≥ïÂä†ËΩΩraw1Ë°®Êï∞ÊçÆ: {e}")
            raw1_data = None
        
        # Á°Æ‰øùÁ¥¢ÂºïÊòØÊó•ÊúüÁ±ªÂûã
        if daily_monitor.index.name == 'Date':
            daily_monitor.index = pd.to_datetime(daily_monitor.index, errors='coerce')
        
        # ËøáÊª§ÊéâÂ∫ïÈÉ®ÁöÑÊó•ÊúüË°åÔºàËøô‰∫õË°åÁöÑÊâÄÊúâÊï∞ÊçÆÂàóÈÉΩÊòØNoneÔºâ
        # ÊâæÂà∞Á¨¨‰∏Ä‰∏™ÊâÄÊúâÂàóÈÉΩÊòØNoneÁöÑË°åÔºåÁÑ∂ÂêéÂè™‰øùÁïôËØ•Ë°å‰πãÂâçÁöÑÊï∞ÊçÆ
        none_mask = daily_monitor.isna().all(axis=1)
        if none_mask.any():
            first_none_row = none_mask.idxmax()
            daily_monitor = daily_monitor.loc[:first_none_row].iloc[:-1]  # ÊéíÈô§Á¨¨‰∏Ä‰∏™ÂÖ®NoneÁöÑË°å
        
        # Á°Æ‰øùÊâÄÊúâÊï∞ÂÄºÂàóÈÉΩÊòØÊï∞ÂÄºÁ±ªÂûãÔºàÊéíÈô§ÈùûÊï∞ÂÄºÂàóÂ¶ÇCapital IQ TickerÔºâ
        numeric_columns = ['Fund Asset(MLN USD)', 'Volume(MLN)', 'Price Change', 'Daily Flow', 
                          'YTD Flow', 'Flow since Jan 2023', 'Expense Ratio', 'Return since 2024', 
                          'Return since 2025', '30D Vol', 'Holdings']
        
        for col in daily_monitor.columns:
            if col in numeric_columns and daily_monitor[col].dtype == 'object':
                daily_monitor[col] = pd.to_numeric(daily_monitor[col], errors='coerce')
        
        # Âä†ËΩΩÊåÅ‰ªì‰ø°ÊÅØ
        holdings = pd.read_excel(
            "ciq reference/data/Shares.xlsx",
            sheet_name="07_30_2025_agix_holdings",
            skiprows=1
        )
        
        # Âä†ËΩΩÊØèÊó•ÁõëÊéßÁöÑholdingsË°®Êï∞ÊçÆ - A1:O47ËåÉÂõ¥
        try:
            daily_holdings = pd.read_excel(
                "ciq reference/data/ÊØèÊó•Êï∞ÊçÆÁõëÊéß.xlsx",
                sheet_name="holdings",
                header=0,  # Á¨¨1Ë°å‰Ωú‰∏∫ÂàóÂêç
                skiprows=[1, 2],  # Ë∑≥ËøáÁ¨¨2-3Ë°åÊó†Áî®‰ø°ÊÅØ
                usecols="A:O",  # ËØªÂèñAÂà∞OÂàó
                nrows=47  # ËØªÂèñ47Ë°åÊï∞ÊçÆ
            )
        except Exception as e:
            st.warning(f"Êó†Ê≥ïÂä†ËΩΩÊØèÊó•ÁõëÊéßholdingsË°®Êï∞ÊçÆ: {e}")
            daily_holdings = None
        
        return filled_pri, shares, daily_monitor, holdings, raw1_data, daily_holdings
    except Exception as e:
        st.error(f"Êï∞ÊçÆÂä†ËΩΩÈîôËØØ: {e}")
        return None, None, None, None, None, None

def calculate_returns(prices, periods=[1, 5, 30, 90, 252]):
    """ËÆ°ÁÆó‰∏çÂêåÊúüÈó¥ÁöÑÊî∂ÁõäÁéá"""
    returns = {}
    for period in periods:
        if len(prices) > period:
            returns[f'{period}d'] = (prices.iloc[0] - prices.iloc[period]) / prices.iloc[period]
    return returns

def calculate_risk_metrics(prices, returns):
    """ËÆ°ÁÆóÈ£éÈô©ÊåáÊ†á"""
    daily_returns = prices.pct_change().dropna()
    
    # Âπ¥ÂåñÊ≥¢Âä®Áéá
    volatility = daily_returns.std() * np.sqrt(252)
    
    # ÊúÄÂ§ßÂõûÊí§
    cumulative_returns = (1 + daily_returns).cumprod()
    rolling_max = cumulative_returns.expanding().max()
    drawdown = (cumulative_returns - rolling_max) / rolling_max
    max_drawdown = drawdown.min()
    
    # VaR (95% ÁΩÆ‰ø°Ê∞¥Âπ≥)
    var_95 = daily_returns.quantile(0.05)
    
    # SharpeÊØîÁéá (ÂÅáËÆæÊó†È£éÈô©Âà©Áéá‰∏∫2%)
    excess_returns = daily_returns - 0.02/252
    sharpe_ratio = excess_returns.mean() / daily_returns.std() * np.sqrt(252)
    
    return {
        'volatility': volatility,
        'max_drawdown': max_drawdown,
        'var_95': var_95,
        'sharpe_ratio': sharpe_ratio
    }

def calculate_contribution(prices, shares):
    """ËÆ°ÁÆóÊåÅ‰ªìË¥°ÁåÆÂ∫¶ÂàÜÊûê"""
    try:
        # ËÆ°ÁÆó‰ª∑Ê†ºÂèòÂåñ
        price_diff = prices.iloc[0] - prices.iloc[1]
        price_delta = price_diff / prices.iloc[1]
        
        # ËÆ°ÁÆó‰ª∑Ê†ºÂΩ±Âìç - ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂàóÁ¥¢Âºï
        if len(shares.columns) > 1:
            shares_col = shares.iloc[:, 1]  # Á¨¨2Âàó
        else:
            shares_col = shares.iloc[:, 0]  # Â¶ÇÊûúÂè™Êúâ1ÂàóÔºå‰ΩøÁî®Á¨¨1Âàó
        
        price_impact = price_diff * shares_col
        
        # ËÆ°ÁÆóÊÄªÂ∏ÇÂÄº
        yesterday_value = prices.iloc[1] * shares_col
        total_value = yesterday_value.sum()
        
        # ËÆ°ÁÆóË¥°ÁåÆÂ∫¶
        contribution = price_impact / total_value
        
        return price_delta, price_impact, contribution
    except Exception as e:
        st.error(f"Ë¥°ÁåÆÂ∫¶ËÆ°ÁÆóÈîôËØØ: {e}")
        return pd.Series(), pd.Series(), pd.Series()

def calculate_cumulative_returns(prices, periods=[30, 90, 180, 252]):
    """ËÆ°ÁÆó‰∏çÂêåÊúüÈó¥ÁöÑÁ¥ØËÆ°Êî∂ÁõäÁéá"""
    try:
        cumulative_returns = {}
        
        for period in periods:
            if len(prices) > period:
                # ËÆ°ÁÆó‰ªéperiodÂ§©ÂâçÂà∞Áé∞Âú®ÁöÑÁ¥ØËÆ°Êî∂ÁõäÁéá
                start_prices = prices.iloc[period]
                end_prices = prices.iloc[0]
                returns = (end_prices - start_prices) / start_prices * 100
                cumulative_returns[f'{period}d'] = returns
        
        return cumulative_returns
    except Exception as e:
        st.error(f"Á¥ØËÆ°Êî∂ÁõäÁéáËÆ°ÁÆóÈîôËØØ: {e}")
        return {}

def calculate_specific_period_returns(prices):
    """ËÆ°ÁÆóÁâπÂÆöÊúüÈó¥ÁöÑÁ¥ØËÆ°Êî∂ÁõäÁéáÔºàsince 2024, since 2025Ôºâ"""
    try:
        specific_returns = {}
        
        # Á°Æ‰øùÁ¥¢ÂºïÊòØÊó•ÊúüÁ±ªÂûãÂπ∂ÊåâÊó∂Èó¥ÊéíÂ∫è
        prices = prices.sort_index()
        
        # ËÆ°ÁÆósince 2024ÁöÑÁ¥ØËÆ°Êî∂ÁõäÁéá
        start_date_2024 = pd.Timestamp('2024-01-01')
        available_dates = prices.index.sort_values()
        
        # ÊâæÂà∞2024Âπ¥Êàñ‰πãÂêéÁöÑÁ¨¨‰∏ÄÂ§©
        start_idx_2024 = None
        for date in available_dates:
            if date >= start_date_2024:
                start_idx_2024 = date
                break
        
        if start_idx_2024 is not None:
            prices_since_2024 = prices.loc[start_idx_2024:].copy()
            if len(prices_since_2024) > 1:
                base_prices_2024 = prices_since_2024.iloc[0]
                current_prices = prices_since_2024.iloc[-1]
                
                for ticker in prices.columns:
                    if ticker in base_prices_2024.index and ticker in current_prices.index:
                        base_price = base_prices_2024[ticker]
                        current_price = current_prices[ticker]
                        if pd.notna(base_price) and base_price != 0:
                            returns_2024 = (current_price - base_price) / base_price * 100
                            specific_returns[f'{ticker}_since2024'] = returns_2024
        
        # ËÆ°ÁÆósince 2025ÁöÑÁ¥ØËÆ°Êî∂ÁõäÁéá
        start_date_2025 = pd.Timestamp('2025-01-01')
        start_idx_2025 = None
        for date in available_dates:
            if date >= start_date_2025:
                start_idx_2025 = date
                break
        
        if start_idx_2025 is not None:
            prices_since_2025 = prices.loc[start_idx_2025:].copy()
            if len(prices_since_2025) > 1:
                base_prices_2025 = prices_since_2025.iloc[0]
                current_prices = prices_since_2025.iloc[-1]
                
                for ticker in prices.columns:
                    if ticker in base_prices_2025.index and ticker in current_prices.index:
                        base_price = base_prices_2025[ticker]
                        current_price = current_prices[ticker]
                        if pd.notna(base_price) and base_price != 0:
                            returns_2025 = (current_price - base_price) / base_price * 100
                            specific_returns[f'{ticker}_since2025'] = returns_2025
        
        return specific_returns
    except Exception as e:
        st.error(f"ÁâπÂÆöÊúüÈó¥Êî∂ÁõäÁéáËÆ°ÁÆóÈîôËØØ: {e}")
        return {}

def plot_cumulative_returns(prices, selected_tickers=None, periods=[30, 90]):
    """ÁªòÂà∂Á¥ØËÆ°Êî∂ÁõäÁéáÂõæË°®"""
    try:
        if prices.empty or len(prices) < 30:
            st.warning("‰ª∑Ê†ºÊï∞ÊçÆ‰∏çË∂≥ÔºåÊó†Ê≥ïËÆ°ÁÆóÁ¥ØËÆ°Êî∂ÁõäÁéá")
            return go.Figure()
        
        # ËÆ°ÁÆó‰∏çÂêåÊúüÈó¥ÁöÑÁ¥ØËÆ°Êî∂ÁõäÁéá
        cumulative_returns = calculate_cumulative_returns(prices, periods)
        
        if not cumulative_returns:
            return go.Figure()
        
        # Â¶ÇÊûúÊ≤°ÊúâÈÄâÊã©TickerÔºå‰ΩøÁî®ÊâÄÊúâÂèØÁî®ÁöÑTicker
        if selected_tickers is None or len(selected_tickers) == 0:
            available_tickers = list(prices.columns)
            selected_tickers = available_tickers[:10]  # ÈªòËÆ§ÊòæÁ§∫Ââç10‰∏™
        
        # ËøáÊª§Âá∫Áî®Êà∑ÈÄâÊã©ÁöÑTicker
        available_tickers = [ticker for ticker in selected_tickers if ticker in prices.columns]
        
        if not available_tickers:
            st.warning("ÊâÄÈÄâTickerÂú®‰ª∑Ê†ºÊï∞ÊçÆ‰∏≠‰∏çÂ≠òÂú®")
            return go.Figure()
        
        # ÂàõÂª∫ÂõæË°®
        fig = go.Figure()
        
        # ‰∏∫ÊØè‰∏™ÊúüÈó¥Ê∑ªÂä†‰∏Ä‰∏™Êù°ÂΩ¢Âõæ
        colors = ['#1f77b4', '#ff7f0e']
        
        for i, (period, returns) in enumerate(cumulative_returns.items()):
            if period in [f'{p}d' for p in periods]:
                # Âè™ÊòæÁ§∫Áî®Êà∑ÈÄâÊã©ÁöÑTickerÁöÑÊï∞ÊçÆ
                period_returns = returns.loc[available_tickers]
                
                fig.add_trace(go.Bar(
                    name=f'{period}Á¥ØËÆ°Êî∂ÁõäÁéá',
                    x=period_returns.index,
                    y=period_returns.values,
                    marker_color=colors[i % len(colors)],
                    text=[f'{x:.1f}%' for x in period_returns.values],
                    textposition='auto',
                    opacity=0.8
                ))
        
        fig.update_layout(
            title=f"ÈÄâÂÆöÊåÅ‰ªìÁ¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØî",
            xaxis_title="ËÇ°Á•®‰ª£Á†Å",
            yaxis_title="Á¥ØËÆ°Êî∂ÁõäÁéá (%)",
            barmode='group',  # ÂàÜÁªÑÊòæÁ§∫
            height=600,
            showlegend=True,
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            )
        )
        
        # Ê∑ªÂä†Èõ∂Á∫ø
        fig.add_hline(y=0, line_dash="dash", line_color="gray", line_width=1)
        
        return fig
    except Exception as e:
        st.error(f"Á¥ØËÆ°Êî∂ÁõäÁéáÂõæË°®ÁîüÊàêÈîôËØØ: {e}")
        return go.Figure()



def plot_cumulative_returns_since_2025(prices, selected_tickers=None):
    """ÁªòÂà∂Ëá™2025Âπ¥ÂàùÁöÑÁ¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØîÂõæÔºàÂπ≥ÊªëÊõ≤Á∫øÂõæÔºâ"""
    try:
        if prices.empty:
            st.warning("‰ª∑Ê†ºÊï∞ÊçÆ‰∏∫Á©∫")
            return go.Figure()
        
        # Á°Æ‰øùÁ¥¢ÂºïÊòØÊó•ÊúüÁ±ªÂûãÂπ∂ÊåâÊó∂Èó¥ÊéíÂ∫è
        prices = prices.sort_index()
        
        # ÊâæÂà∞2025Âπ¥1Êúà1Êó•Êàñ‰πãÂêéÁöÑÁ¨¨‰∏ÄÂ§©
        start_date = pd.Timestamp('2025-01-01')
        available_dates = prices.index.sort_values()
        
        # ÊâæÂà∞2025Âπ¥Êàñ‰πãÂêéÁöÑÁ¨¨‰∏ÄÂ§©
        start_idx = None
        for date in available_dates:
            if date >= start_date:
                start_idx = date
                break
        
        if start_idx is None:
            st.warning("Ê≤°ÊúâÊâæÂà∞2025Âπ¥ÁöÑÊï∞ÊçÆÔºå‰ΩøÁî®ÊúÄÊñ∞Êï∞ÊçÆ")
            # Â¶ÇÊûúÊ≤°Êúâ2025Âπ¥Êï∞ÊçÆÔºå‰ΩøÁî®ÊúÄËøë30Â§©ÁöÑÊï∞ÊçÆ
            start_idx = available_dates[-30] if len(available_dates) >= 30 else available_dates[0]
        
        # Ëé∑Âèñ‰ªéËµ∑ÂßãÊó•ÊúüÂºÄÂßãÁöÑÊï∞ÊçÆ
        prices_since_start = prices.loc[start_idx:].copy()
        
        if len(prices_since_start) < 2:
            st.warning("Êï∞ÊçÆ‰∏çË∂≥")
            return go.Figure()
        
        # Â¶ÇÊûúÊ≤°ÊúâÈÄâÊã©TickerÔºå‰ΩøÁî®ÊâÄÊúâÂèØÁî®ÁöÑTicker
        if selected_tickers is None or len(selected_tickers) == 0:
            available_tickers = list(prices.columns)
            selected_tickers = available_tickers[:10]  # ÈªòËÆ§ÊòæÁ§∫Ââç10‰∏™
        
        # ËøáÊª§Âá∫Áî®Êà∑ÈÄâÊã©ÁöÑTicker
        available_tickers = [ticker for ticker in selected_tickers if ticker in prices.columns]
        
        if not available_tickers:
            st.warning("ÊâÄÈÄâTickerÂú®‰ª∑Ê†ºÊï∞ÊçÆ‰∏≠‰∏çÂ≠òÂú®")
            return go.Figure()
        
        # ËÆ°ÁÆóÁ¥ØËÆ°Êî∂ÁõäÁéáÔºà‰ª•Ëµ∑ÂßãÊó•Êúü‰∏∫Âü∫ÂáÜÔºâ
        base_prices = prices_since_start.iloc[0]
        cumulative_returns = {}
        
        for ticker in available_tickers:
            if ticker in prices_since_start.columns:
                price_series = prices_since_start[ticker]
                base_price = base_prices[ticker]
                if pd.notna(base_price) and base_price != 0:
                    # ËÆ°ÁÆóÊØèÊó•Á¥ØËÆ°Êî∂ÁõäÁéá
                    returns = (price_series - base_price) / base_price * 100
                    cumulative_returns[ticker] = returns
        
        if not cumulative_returns:
            st.warning("Êó†Ê≥ïËÆ°ÁÆóÁ¥ØËÆ°Êî∂ÁõäÁéá")
            return go.Figure()
        
        # ÂàõÂª∫ÂõæË°®
        fig = go.Figure()
        
        # È¢úËâ≤ÂàóË°®
        colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                 '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']
        
        for i, (ticker, returns) in enumerate(cumulative_returns.items()):
            # ÁßªÈô§NaNÂÄºÔºå‰ΩÜ‰øùÁïôÊúâÊïàÁöÑÊï∞ÊçÆÁÇπ
            valid_data = returns.dropna()
            if len(valid_data) > 1:  # Ëá≥Â∞ëÈúÄË¶Å2‰∏™ÁÇπÊâçËÉΩÁîªÁ∫ø
                fig.add_trace(go.Scatter(
                    x=valid_data.index,
                    y=valid_data.values,
                    mode='lines',
                    name=ticker,
                    line=dict(color=colors[i % len(colors)], width=2),
                    hovertemplate=f'{ticker}<br>Êó•Êúü: %{{x}}<br>Á¥ØËÆ°Êî∂ÁõäÁéá: %{{y:.2f}}%<extra></extra>'
                ))
        
        # ËÆæÁΩÆÂõæË°®Ê†áÈ¢ò
        if start_idx >= pd.Timestamp('2025-01-01'):
            title = "Ëá™2025Âπ¥ÂàùÁ¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØî"
        else:
            title = f"Ëá™{start_idx.strftime('%Y-%m-%d')}Á¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØî"
        
        fig.update_layout(
            title=title,
            xaxis_title="Êó•Êúü",
            yaxis_title="Á¥ØËÆ°Êî∂ÁõäÁéá (%)",
            height=500,
            showlegend=True,
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            ),
            hovermode='x unified'
        )
        
        # Ê∑ªÂä†Èõ∂Á∫ø
        fig.add_hline(y=0, line_dash="dash", line_color="gray", line_width=1)
        
        return fig
    except Exception as e:
        st.error(f"Á¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØîÂõæÁîüÊàêÈîôËØØ: {e}")
        return go.Figure()


def plot_contribution_analysis(contribution, top_n=10):
    """ÁªòÂà∂Ë¥°ÁåÆÂ∫¶ÂàÜÊûêÂõæË°®"""
    try:
        if contribution.empty:
            st.warning("Ë¥°ÁåÆÂ∫¶Êï∞ÊçÆ‰∏∫Á©∫")
            return go.Figure()
        
        # Ëé∑ÂèñË¥°ÁåÆÂ∫¶ÁªùÂØπÂÄºÊúÄÂ§ßÁöÑÂâçN‰∏™ÊåÅ‰ªìÔºå‰ΩÜ‰øùÁïôÂéüÂßãÁ¨¶Âè∑
        top_contributors_abs = contribution.abs().nlargest(top_n)
        top_contributors = contribution.loc[top_contributors_abs.index]
        
        fig = go.Figure()
        
        colors = ['red' if x < 0 else 'green' for x in top_contributors]
        
        fig.add_trace(go.Bar(
            x=top_contributors.index,
            y=top_contributors.values * 100,
            marker_color=colors,
            text=[f'{x:.2f}%' for x in top_contributors.values * 100],
            textposition='auto'
        ))
        
        fig.update_layout(
            title=f"Top {top_n} Holdings Contribution to Fund Performance",
            xaxis_title="Holdings",
            yaxis_title="Contribution (%)",
            height=500
        )
        
        return fig
    except Exception as e:
        st.error(f"Ë¥°ÁåÆÂ∫¶ÂõæË°®ÁîüÊàêÈîôËØØ: {e}")
        return go.Figure()

def plot_sector_allocation(holdings):
    """ÁªòÂà∂Ë°å‰∏öÈÖçÁΩÆÂõæË°®"""
    try:
        if holdings is None or 'Sector' not in holdings.columns:
            return None
        
        sector_counts = holdings['Sector'].value_counts()
        
        fig = px.pie(
            values=sector_counts.values,
            names=sector_counts.index,
            title="Sector Allocation by Company Count"
        )
        
        fig.update_layout(height=400)
        return fig
    except Exception as e:
        st.error(f"Ë°å‰∏öÈÖçÁΩÆÂõæË°®ÁîüÊàêÈîôËØØ: {e}")
        return None

def plot_sector_market_cap(holdings):
    """ÁªòÂà∂ÊåâÂ∏ÇÂÄºÁöÑË°å‰∏öÈÖçÁΩÆÂõæË°®"""
    try:
        if holdings is None or 'Sector' not in holdings.columns:
            return None
        
        # Êü•ÊâæÂ∏ÇÂÄºÂàóÔºàÂèØËÉΩÁöÑÂàóÂêçÔºâ
        market_cap_col = None
        possible_market_cap_cols = ['Market Cap', 'MarketCap', 'Market_Cap', 'MarketCap(MLN)', 'Market Cap(MLN)', 'Â∏ÇÂÄº', 'Market Value']
        
        for col in holdings.columns:
            if any(mc in str(col) for mc in possible_market_cap_cols):
                market_cap_col = col
                break
        
        if market_cap_col is None:
            st.warning("Êú™ÊâæÂà∞Â∏ÇÂÄºÂàóÔºåÊó†Ê≥ïÁîüÊàêÊåâÂ∏ÇÂÄºÁöÑË°å‰∏öÈÖçÁΩÆÂõæ")
            return None
        
        # ÊåâË°å‰∏öÊ±áÊÄªÂ∏ÇÂÄº
        sector_market_cap = holdings.groupby('Sector')[market_cap_col].sum()
        
        fig = px.pie(
            values=sector_market_cap.values,
            names=sector_market_cap.index,
            title=f"Sector Allocation by Market Cap ({market_cap_col})"
        )
        
        fig.update_layout(height=400)
        return fig
    except Exception as e:
        st.error(f"ÊåâÂ∏ÇÂÄºÁöÑË°å‰∏öÈÖçÁΩÆÂõæË°®ÁîüÊàêÈîôËØØ: {e}")
        return None

def calculate_sector_contribution(holdings):
    """ËÆ°ÁÆóË°å‰∏öË¥°ÁåÆË°®Ê†º"""
    try:
        if holdings is None or 'Sector' not in holdings.columns:
            return None
        
        # Êü•ÊâæË¥°ÁåÆÂ∫¶ÂàóÔºàÂèØËÉΩÁöÑÂàóÂêçÔºâ
        contribution_col = None
        possible_contribution_cols = ['Contribute']
        
        for col in holdings.columns:
            if any(contrib in str(col) for contrib in possible_contribution_cols):
                contribution_col = col
                break
        
        if contribution_col is None:
            st.warning("Êú™ÊâæÂà∞Ë¥°ÁåÆÂ∫¶ÂàóÔºåÊó†Ê≥ïÁîüÊàêË°å‰∏öË¥°ÁåÆË°®Ê†º")
            return None
        
        # ÊåâË°å‰∏öÊ±áÊÄªË¥°ÁåÆÂ∫¶
        sector_contribution = holdings.groupby('Sector')[contribution_col].sum()
        
        # ÂàõÂª∫Ë¥°ÁåÆË°®Ê†º
        contribution_df = pd.DataFrame({
            'Ë°å‰∏ö': sector_contribution.index,
            'Ë¥°ÁåÆÂ∫¶ÊÄªÂíå': sector_contribution.values
        })
        
        # ÊåâË¥°ÁåÆÂ∫¶ÊéíÂ∫è
        contribution_df = contribution_df.sort_values('Ë¥°ÁåÆÂ∫¶ÊÄªÂíå', ascending=False)
        
        return contribution_df
    except Exception as e:
        st.error(f"Ë°å‰∏öË¥°ÁåÆËÆ°ÁÆóÈîôËØØ: {e}")
        return None

def main():
    # ‰∏ªÊ†áÈ¢ò
    st.markdown('<h1 class="main-header">üìä AGIX Fund Monitor</h1>', unsafe_allow_html=True)
    
    # Âä†ËΩΩÊï∞ÊçÆ
    with st.spinner("Ê≠£Âú®Âä†ËΩΩÊï∞ÊçÆ..."):
        filled_pri, shares, daily_monitor, holdings, raw1_data, daily_holdings = load_data()
    
    if filled_pri is None:
        st.error("Êó†Ê≥ïÂä†ËΩΩÊï∞ÊçÆÔºåËØ∑Ê£ÄÊü•Êñá‰ª∂Ë∑ØÂæÑ")
        return
    
    # ‰æßËæπÊ†è
    st.sidebar.header("üìà ÁõëÊéßËÆæÁΩÆ")
    
    # Âç†‰ΩçÁ¨¶ - Êú™Êù•ÂèØÊ∑ªÂä†ÁõëÊéßËÆæÁΩÆÂäüËÉΩ
    st.sidebar.info("ÁõëÊéßËÆæÁΩÆÂäüËÉΩÊ≠£Âú®ÂºÄÂèë‰∏≠...")
    st.sidebar.write("Êú™Êù•Â∞ÜÊîØÊåÅÔºö")
    st.sidebar.write("‚Ä¢ Ëá™ÂÆö‰πâÊó∂Èó¥ËåÉÂõ¥")
    st.sidebar.write("‚Ä¢ È£éÈô©È¢ÑË≠¶ËÆæÁΩÆ")
    st.sidebar.write("‚Ä¢ Êî∂ÁõäÁéáÁõÆÊ†áËÆæÁΩÆ")
    st.sidebar.write("‚Ä¢ Ëá™Âä®Êä•ÂëäÁîüÊàê")
    

    
    # ‰∏ªÈ°µÈù¢Ê†áÁ≠æ
    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
        "üìä Ê¶ÇËßà", 
        "üìä Âü∫ÈáëÂØπÊØî",
        "üéØ Ë¥°ÁåÆÂ∫¶ÂàÜÊûê", 
        "üìà ÊåÅ‰ªìÊî∂ÁõäÁéáÂàÜÊûê", 
        "‚ö†Ô∏è È£éÈô©ÂàÜÊûê", 
        "üìã ÊåÅ‰ªìËØ¶ÊÉÖ"
    ])
    
    # Ê¶ÇËßàÊ†áÁ≠æÈ°µ
    with tab1:
        st.header("üìä Âü∫ÈáëÊ¶ÇËßà")
        
        col1, col2, col3, col4 = st.columns(4)
        
        # ËÆ°ÁÆóÂÖ≥ÈîÆÊåáÊ†á
        if len(filled_pri) > 1:
            try:
                current_value = filled_pri.iloc[0].sum()
                prev_value = filled_pri.iloc[1].sum()
                
                # ËÆ°ÁÆóÊó•Êî∂ÁõäÁéá
                if pd.notna(prev_value) and prev_value != 0:
                    daily_return = (current_value - prev_value) / prev_value
                    daily_return_str = f"{daily_return:.2%}"
                else:
                    daily_return_str = "N/A"
                
                with col1:
                    if pd.notna(current_value):
                        st.metric(
                            "ÂΩìÂâçÂáÄÂÄº",
                            f"${current_value:,.2f}",
                            daily_return_str,
                            delta_color="normal"
                        )
                    else:
                        st.metric("ÂΩìÂâçÂáÄÂÄº", "N/A", "Êï∞ÊçÆÊó†Êïà")
                
                with col2:
                    st.metric(
                        "ÊåÅ‰ªìÊï∞Èáè",
                        len(shares),
                        "",
                        delta_color="normal"
                    )
                
                with col3:
                    # ËÆ°ÁÆóÂπ¥ÂåñÊî∂ÁõäÁéá
                    try:
                        if len(filled_pri) > 252:
                            # Â¶ÇÊûúÊúâË∂ÖËøá‰∏ÄÂπ¥ÁöÑÊï∞ÊçÆÔºå‰ΩøÁî®‰∏ÄÂπ¥ÂâçÁöÑÊï∞ÊçÆ
                            past_value = filled_pri.iloc[252].sum()
                            if pd.notna(past_value) and past_value != 0:
                                annual_return = (current_value / past_value - 1)
                                st.metric(
                                    "Âπ¥ÂåñÊî∂ÁõäÁéá",
                                    f"{annual_return:.2%}",
                                    "",
                                    delta_color="normal"
                                )
                            else:
                                st.metric("Âπ¥ÂåñÊî∂ÁõäÁéá", "N/A", "Êï∞ÊçÆÊó†Êïà")
                        elif len(filled_pri) > 30:
                            # Â¶ÇÊûúÊï∞ÊçÆ‰∏çË∂≥‰∏ÄÂπ¥‰ΩÜË∂ÖËøá30Â§©Ôºå‰ΩøÁî®Âπ¥ÂåñËÆ°ÁÆó
                            days_available = len(filled_pri) - 1
                            past_value = filled_pri.iloc[-1].sum()
                            if pd.notna(past_value) and past_value != 0:
                                total_return = (current_value / past_value - 1)
                                annual_return = (1 + total_return) ** (252 / days_available) - 1
                                st.metric(
                                    "Âπ¥ÂåñÊî∂ÁõäÁéá",
                                    f"{annual_return:.2%}",
                                    f"(Âü∫‰∫é{days_available}Â§©Êï∞ÊçÆ)",
                                    delta_color="normal"
                                )
                            else:
                                st.metric("Âπ¥ÂåñÊî∂ÁõäÁéá", "N/A", "Êï∞ÊçÆÊó†Êïà")
                        else:
                            st.metric("Âπ¥ÂåñÊî∂ÁõäÁéá", "N/A", "Êï∞ÊçÆ‰∏çË∂≥")
                    except Exception as e:
                        st.metric("Âπ¥ÂåñÊî∂ÁõäÁéá", "N/A", f"ËÆ°ÁÆóÈîôËØØ")
                
                with col4:
                    # ËÆ°ÁÆóÊ≥¢Âä®Áéá
                    try:
                        daily_returns = filled_pri.pct_change().dropna()
                        if not daily_returns.empty:
                            volatility = daily_returns.std().mean() * np.sqrt(252)
                            if pd.notna(volatility):
                                st.metric(
                                    "Âπ¥ÂåñÊ≥¢Âä®Áéá",
                                    f"{volatility:.2%}",
                                    "",
                                    delta_color="normal"
                                )
                            else:
                                st.metric("Âπ¥ÂåñÊ≥¢Âä®Áéá", "N/A", "Êï∞ÊçÆÊó†Êïà")
                        else:
                            st.metric("Âπ¥ÂåñÊ≥¢Âä®Áéá", "N/A", "Êï∞ÊçÆ‰∏çË∂≥")
                    except Exception as e:
                        st.metric("Âπ¥ÂåñÊ≥¢Âä®Áéá", "N/A", "ËÆ°ÁÆóÈîôËØØ")
            except Exception as e:
                st.error(f"ÊåáÊ†áËÆ°ÁÆóÈîôËØØ: {e}")
        
        # Âü∫ÈáëÊ¶ÇËßà‰ø°ÊÅØ
        st.subheader("üìä Âü∫ÈáëÂü∫Êú¨‰ø°ÊÅØ")
        if daily_monitor is not None and len(daily_monitor) > 0:
            try:
                # ÊòæÁ§∫ÊúÄÊñ∞ÁöÑÂü∫ÈáëËµÑ‰∫ß‰ø°ÊÅØ
                latest_data = daily_monitor.iloc[0] if len(daily_monitor) > 0 else None
                if latest_data is not None and 'Fund Asset(MLN USD)' in latest_data:
                    fund_asset = latest_data['Fund Asset(MLN USD)']
                    st.metric("Âü∫ÈáëËµÑ‰∫ßËßÑÊ®°", f"${fund_asset:,.2f}M")
            except Exception as e:
                st.error(f"ÊòæÁ§∫Âü∫Èáë‰ø°ÊÅØÊó∂Âá∫Èîô: {e}")
        else:
            st.warning("Êó†Ê≥ïÂä†ËΩΩÂü∫ÈáëÂü∫Êú¨‰ø°ÊÅØ")
        
        # AGIXË°®Áé∞ÊÄªÁªì
        if raw1_data is not None:
            st.subheader("üéØ AGIXË°®Áé∞ÊÄªÁªì")
            agix_data = raw1_data[raw1_data['Name'] == 'ETNA']
            if not agix_data.empty:
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    if 'DTD' in agix_data.columns:
                        dtd_val = pd.to_numeric(agix_data['DTD'].iloc[0], errors='coerce') * 100
                        st.metric("Êó•Êî∂ÁõäÁéá", f"{dtd_val:.2f}%" if pd.notna(dtd_val) else "N/A")
                
                with col2:
                    if 'WTD' in agix_data.columns:
                        wtd_val = pd.to_numeric(agix_data['WTD'].iloc[0], errors='coerce') * 100
                        st.metric("Âë®Êî∂ÁõäÁéá", f"{wtd_val:.2f}%" if pd.notna(wtd_val) else "N/A")
                
                with col3:
                    if 'YTD' in agix_data.columns:
                        ytd_val = pd.to_numeric(agix_data['YTD'].iloc[0], errors='coerce') * 100
                        st.metric("Âπ¥Êî∂ÁõäÁéá", f"{ytd_val:.2f}%" if pd.notna(ytd_val) else "N/A")
                
                with col4:
                    if 'Return since 2024' in agix_data.columns:
                        ret_2024_val = pd.to_numeric(agix_data['Return since 2024'].iloc[0], errors='coerce') * 100
                        st.metric("2024Âπ¥Êî∂Áõä", f"{ret_2024_val:.2f}%" if pd.notna(ret_2024_val) else "N/A")
        
 
    
    # Âü∫ÈáëÂØπÊØîÊ†áÁ≠æÈ°µ
    with tab2:
        st.header("üìä Âü∫ÈáëÂØπÊØî")
        
        # Á¨¨‰∏ÄÈÉ®ÂàÜÔºöAGIX‰∏é‰∏ªË¶ÅÂü∫ÈáëÂØπÊØîË°®Ê†º
        if raw1_data is not None:
            st.subheader("üìã AGIX‰∏é‰∏ªË¶ÅÂü∫ÈáëÂØπÊØîÊï∞ÊçÆ")
            st.write("**Âü∫ÈáëÊî∂ÁõäÁéáÂØπÊØîË°®Ê†º:**")
            
            # ÂàõÂª∫Ê†ºÂºèÂåñÂêéÁöÑÊï∞ÊçÆÊ°ÜÁî®‰∫éÊòæÁ§∫
            display_raw1 = raw1_data.copy()
            
            # ÂÆö‰πâÈúÄË¶Å‰ª•ÁôæÂàÜÊØîÂΩ¢ÂºèÊòæÁ§∫ÁöÑÂàó
            percentage_columns = ['DTD', 'WTD', 'YTD', 'Return since 2024', 'Return since launch']
            
            # Â∫îÁî®ÁôæÂàÜÊØîÊ†ºÂºèÂåñ
            for col in percentage_columns:
                if col in display_raw1.columns:
                    # Á°Æ‰øùÊï∞ÊçÆÊòØÊï∞ÂÄºÁ±ªÂûã
                    display_raw1[col] = pd.to_numeric(display_raw1[col], errors='coerce')
                    # ËΩ¨Êç¢‰∏∫ÁôæÂàÜÊØîÊ†ºÂºè
                    display_raw1[col] = display_raw1[col].apply(lambda x: f"{x:.2f}%" if pd.notna(x) else "")
            
            # Á°Æ‰øùÊâÄÊúâÂàóÈÉΩÊòØÂ≠óÁ¨¶‰∏≤Á±ªÂûãÔºåÈÅøÂÖçArrowÂ∫èÂàóÂåñÈóÆÈ¢ò
            for col in display_raw1.columns:
                display_raw1[col] = display_raw1[col].astype(str)
            
            st.dataframe(display_raw1, use_container_width=True)
            
            # Á¨¨‰∫åÈÉ®ÂàÜÔºöÊî∂ÁõäÁéáÂØπÊØîÂõæË°®
            st.subheader("üìà Êî∂ÁõäÁéáÂØπÊØîÂõæË°®")
            
            # ÈÄâÊã©Ë¶ÅÂ±ïÁ§∫ÁöÑÊåáÊï∞/Âü∫Èáë
            # ÂàõÂª∫Âü∫ÈáëÂêçÁß∞Âà∞tickerÁöÑÊò†Â∞Ñ
            fund_mapping = dict(zip(raw1_data['Ticker.1'], raw1_data['Name']))
            available_tickers = raw1_data['Ticker.1'].tolist()
            
            selected_tickers = st.multiselect(
                "ÈÄâÊã©Ë¶ÅÂØπÊØîÁöÑÊåáÊï∞/Âü∫Èáë:",
                available_tickers,
                default=available_tickers  # ÈªòËÆ§ÈÄâÊã©ÊâÄÊúâÂü∫Èáë
            )
            
            # Â∞ÜÈÄâ‰∏≠ÁöÑtickerËΩ¨Êç¢‰∏∫ÂØπÂ∫îÁöÑÂü∫ÈáëÂêçÁß∞Áî®‰∫éÊï∞ÊçÆËøáÊª§
            selected_funds = [fund_mapping[ticker] for ticker in selected_tickers if ticker in fund_mapping]
            
            if selected_funds:
                # ÂàõÂª∫ÂàÜÁªÑÊü±Áä∂Âõæ
                fig = go.Figure()
                
                # ÂÆö‰πâÊåáÊ†áÈ¢úËâ≤ÊñπÊ°à - ÊØè‰∏™ÊåáÊ†á‰∏Ä‰∏™Âõ∫ÂÆöÈ¢úËâ≤
                metric_colors = {
                    'DTD': '#1f77b4',      # ËìùËâ≤
                    'WTD': '#ff7f0e',      # Ê©ôËâ≤
                    'YTD': '#2ca02c',      # ÁªøËâ≤
                    'Return since 2024': '#d62728'  # Á∫¢Ëâ≤
                }
                
                # ËøáÊª§ÈÄâ‰∏≠ÁöÑÂü∫ÈáëÊï∞ÊçÆ
                filtered_data = raw1_data[raw1_data['Name'].isin(selected_funds)]
                
                # ‰∏∫ÊØè‰∏™ÊåáÊ†áÂàõÂª∫Êü±Áä∂Âõæ
                for i, metric in enumerate(['DTD', 'WTD', 'YTD', 'Return since 2024']):
                    if metric in filtered_data.columns:
                        # Ëé∑ÂèñÊï∞ÂÄºÊï∞ÊçÆÔºà‰∏çÂåÖÂê´ÁôæÂàÜÊØîÁ¨¶Âè∑Ôºâ
                        values = pd.to_numeric(filtered_data[metric], errors='coerce') * 100  # ËΩ¨Êç¢‰∏∫ÁôæÂàÜÊØî
                        
                        # ‰∏∫ÊØè‰∏™Âü∫ÈáëËÆæÁΩÆÈ¢úËâ≤ÔºåAGIXÁ™ÅÂá∫ÊòæÁ§∫
                        fund_colors = []
                        for name in filtered_data['Name']:
                            if name == 'ETNA':
                                fund_colors.append(metric_colors[metric])  # AGIX‰ΩøÁî®ÊåáÊ†áÈ¢úËâ≤
                            else:
                                fund_colors.append(metric_colors[metric])  # ÂÖ∂‰ªñÂü∫Èáë‰πü‰ΩøÁî®Áõ∏ÂêåÈ¢úËâ≤
                        
                        fig.add_trace(go.Bar(
                            name=metric,
                            x=filtered_data['Ticker.1'],  # ‰ΩøÁî®Ticker.1Âàó‰Ωú‰∏∫XËΩ¥Ê†áÁ≠æ
                            y=values,
                            marker_color=fund_colors,
                            text=[f'{val:.2f}%' if pd.notna(val) else '' for val in values],
                            textposition='auto',
                            textfont=dict(size=10),
                            offsetgroup=i,
                            width=0.15,
                            opacity=0.8
                        ))
                
                # Êõ¥Êñ∞Â∏ÉÂ±Ä
                fig.update_layout(
                    title=dict(
                        text="AGIX‰∏é‰∏ªË¶ÅÂü∫ÈáëÊî∂ÁõäÁéáÂØπÊØî",
                        x=0.5,
                        font=dict(size=16, color='white')
                    ),
                    xaxis_title="Âü∫Èáë/ÊåáÊï∞",
                    yaxis_title="Êî∂ÁõäÁéá (%)",
                    barmode='group',
                    height=600,
                    showlegend=True,
                    legend=dict(
                        orientation="h",
                        yanchor="bottom",
                        y=1.02,
                        xanchor="right",
                        x=1,
                        bgcolor='rgba(0,0,0,0)',
                        bordercolor='rgba(0,0,0,0)'
                    ),
                    plot_bgcolor='rgba(0,0,0,0)',
                    paper_bgcolor='rgba(0,0,0,0)',
                    font=dict(color='white'),
                    margin=dict(t=80, b=80, l=80, r=80)
                )
                
                # Êõ¥Êñ∞xËΩ¥Ê†∑Âºè
                fig.update_xaxes(
                    showgrid=True,
                    gridwidth=1,
                    gridcolor='rgba(128,128,128,0.2)',
                    tickangle=45
                )
                
                # Êõ¥Êñ∞yËΩ¥Ê†∑Âºè
                fig.update_yaxes(
                    showgrid=True,
                    gridwidth=1,
                    gridcolor='rgba(128,128,128,0.2)',
                    zeroline=True,
                    zerolinecolor='rgba(128,128,128,0.5)',
                    zerolinewidth=1
                )
                
                # Ê∑ªÂä†Ê∞¥Âπ≥Èõ∂Á∫ø
                fig.add_hline(y=0, line_dash="dash", line_color="rgba(128,128,128,0.8)", line_width=1)
                
                st.plotly_chart(fig, use_container_width=True)
         
        # Á¨¨‰∏âÈÉ®ÂàÜÔºöËØ¶ÁªÜÂü∫ÈáëÂØπÊØîÊï∞ÊçÆ
        if daily_monitor is not None:
            st.subheader("üìä ËØ¶ÁªÜÂü∫ÈáëÂØπÊØîÊï∞ÊçÆ")
            st.write("**Âü∫Èáë‰∏éÂü∫ÂáÜÊåáÊï∞ËØ¶ÁªÜÂØπÊØî:**")
            
            try:
                # Á°Æ‰øùÊï∞ÊçÆÁ±ªÂûãÊ≠£Á°ÆÔºàÊéíÈô§ÈùûÊï∞ÂÄºÂàóÂ¶ÇCapital IQ TickerÔºâ
                display_monitor = daily_monitor.copy()
                numeric_columns = ['Fund Asset(MLN USD)', 'Volume(MLN)', 'Price Change', 'Daily Flow', 
                                  'YTD Flow', 'Flow since Jan 2023', 'Expense Ratio', 'Return since 2024', 
                                  'Return since 2025', '30D Vol', 'Holdings']
                
                for col in display_monitor.columns:
                    if col in numeric_columns and display_monitor[col].dtype == 'object':
                        display_monitor[col] = pd.to_numeric(display_monitor[col], errors='coerce')
                
                # Á°Æ‰øùÊâÄÊúâÂàóÈÉΩÊòØÊï∞ÂÄºÊàñÂ≠óÁ¨¶‰∏≤Á±ªÂûãÔºåÈÅøÂÖçArrowÂ∫èÂàóÂåñÈóÆÈ¢ò
                for col in display_monitor.columns:
                    if display_monitor[col].dtype == 'object':
                        display_monitor[col] = display_monitor[col].astype(str)
                
                st.dataframe(display_monitor, use_container_width=True)
                
            except Exception as e:
                st.error(f"ÊòæÁ§∫ËØ¶ÁªÜÂü∫ÈáëÂØπÊØîÊï∞ÊçÆÊó∂Âá∫Èîô: {e}")
                st.write("Êó†Ê≥ïÊòæÁ§∫ËØ¶ÁªÜÂü∫ÈáëÂØπÊØîÊï∞ÊçÆ")
        else:
            st.warning("Êó†Ê≥ïÂä†ËΩΩËØ¶ÁªÜÂü∫ÈáëÂØπÊØîÊï∞ÊçÆ")
    
    # ÊåÅ‰ªìÊî∂ÁõäÁéáÂàÜÊûêÊ†áÁ≠æÈ°µ
    with tab4:
        st.header("üìà ÊåÅ‰ªìÊî∂ÁõäÁéáÂàÜÊûê")
        
        try:
            # ËÆ°ÁÆó‰∏çÂêåÊúüÈó¥ÁöÑÊî∂ÁõäÁéá
            returns = calculate_returns(filled_pri)
            
            # ÂáÜÂ§áÊî∂ÁõäÁéáÊï∞ÊçÆÁî®‰∫éÁÉ≠ÂäõÂõæ
            returns_df = pd.DataFrame(returns).T
            returns_df = returns_df * 100  # ËΩ¨Êç¢‰∏∫ÁôæÂàÜÊØî
            
            # Á°Æ‰øùÊï∞ÊçÆÁ±ªÂûãÂÖºÂÆπ
            returns_df = returns_df.astype(float)
            
            # Êî∂ÁõäÁéáÁÉ≠ÂäõÂõæ
            st.subheader("Êî∂ÁõäÁéáÁÉ≠ÂäõÂõæ")
            fig = px.imshow(
                returns_df,
                aspect="auto",
                title="Returns Heatmap by Period"
            )
            st.plotly_chart(fig, use_container_width=True)
            
            # Á¥ØËÆ°Êî∂ÁõäÁéáÂàÜÊûê
            st.subheader("üìà Á¥ØËÆ°Êî∂ÁõäÁéáÂàÜÊûê")
            
            # Ëé∑ÂèñÊâÄÊúâÂèØÁî®ÁöÑTicker
            available_tickers = list(filled_pri.columns)
            
            # ËÆ°ÁÆó30Â§©Êî∂ÁõäÁéáÊù•Ëé∑ÂèñTop 10 Holdings
            cumulative_returns_30d = calculate_cumulative_returns(filled_pri, [30])
            if '30d' in cumulative_returns_30d:
                top_10_holdings = cumulative_returns_30d['30d'].nlargest(10).index.tolist()
            else:
                top_10_holdings = available_tickers[:10]
            
            # ÂàõÂª∫Â§öÈÄâÂô®
            selected_tickers = st.multiselect(
                "ÈÄâÊã©Ë¶ÅÊòæÁ§∫ÁöÑËÇ°Á•®‰ª£Á†Å:",
                options=available_tickers,
                default=top_10_holdings,
                help="ÈªòËÆ§ÊòæÁ§∫30Â§©Êî∂ÁõäÁéáÊúÄÈ´òÁöÑÂâç10‰∏™ÊåÅ‰ªì"
            )
            
            # ÁªòÂà∂Á¥ØËÆ°Êî∂ÁõäÁéáÂõæË°®
            if selected_tickers:
                cum_returns_fig = plot_cumulative_returns(filled_pri, selected_tickers, [30, 90])
                st.plotly_chart(cum_returns_fig, use_container_width=True)
            else:
                st.warning("ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™ËÇ°Á•®‰ª£Á†Å")
            
            # Á¥ØËÆ°Êî∂ÁõäÁéáËØ¶ÁªÜÊï∞ÊçÆË°®Ê†º
            st.subheader("üìä Á¥ØËÆ°Êî∂ÁõäÁéáËØ¶ÁªÜÊï∞ÊçÆ")
            
            # ËÆ°ÁÆóÁ¥ØËÆ°Êî∂ÁõäÁéáÊï∞ÊçÆ - Ê∑ªÂä†Êõ¥Â§öÊúüÈó¥
            cumulative_returns_data = calculate_cumulative_returns(filled_pri, [1, 5, 30, 90])
            
            if cumulative_returns_data:
                # ÂàõÂª∫Á¥ØËÆ°Êî∂ÁõäÁéáË°®Ê†º
                returns_df_cum = pd.DataFrame(cumulative_returns_data)
                
                # ËÆ°ÁÆóÁâπÂÆöÊúüÈó¥ÁöÑÊî∂ÁõäÁéá
                specific_returns = calculate_specific_period_returns(filled_pri)
                
                # Ê∑ªÂä†since2024Âíåsince2025Êï∞ÊçÆ
                if specific_returns:
                    # Â∞ÜÁâπÂÆöÊúüÈó¥Êï∞ÊçÆËΩ¨Êç¢‰∏∫DataFrameÊ†ºÂºè
                    since2024_data = {}
                    since2025_data = {}
                    
                    for key, value in specific_returns.items():
                        if key.endswith('_since2024'):
                            ticker = key.replace('_since2024', '')
                            since2024_data[ticker] = value
                        elif key.endswith('_since2025'):
                            ticker = key.replace('_since2025', '')
                            since2025_data[ticker] = value
                    
                    # Ê∑ªÂä†Âà∞‰∏ªË°®Ê†º
                    if since2024_data:
                        returns_df_cum['since2024'] = pd.Series(since2024_data)
                    if since2025_data:
                        returns_df_cum['since2025'] = pd.Series(since2025_data)
                
                # Ê∑ªÂä†ÊåÅ‰ªìÊùÉÈáç‰ø°ÊÅØ
                if len(shares.columns) > 1:
                    shares_col = shares.iloc[:, 1]  # Á¨¨2Âàó
                else:
                    shares_col = shares.iloc[:, 0]  # Â¶ÇÊûúÂè™Êúâ1ÂàóÔºå‰ΩøÁî®Á¨¨1Âàó
                
                yesterday_value = filled_pri.iloc[1] * shares_col
                total_value = yesterday_value.sum()
                weight = yesterday_value / total_value * 100
                
                returns_df_cum['Weight(%)'] = weight
                
                # ÈáçÊñ∞ÊéíÂ∫èÂàó - ÊåâÊó∂Èó¥È°∫Â∫èÂíåÈáçË¶ÅÊÄßÊéíÂ∫è
                column_order = ['1d', '5d', '30d', '90d', 'since2024', 'since2025', 'Weight(%)']
                available_columns = [col for col in column_order if col in returns_df_cum.columns]
                returns_df_cum = returns_df_cum[available_columns]
                
                # Ê†ºÂºèÂåñÊòæÁ§∫ - Âè™ÂØπÊî∂ÁõäÁéáÂàóÂ∫îÁî®È¢úËâ≤ÔºåÊùÉÈáçÂàó‰øùÊåÅÁôΩËâ≤
                def color_returns_only(df):
                    """Âè™ÂØπÊî∂ÁõäÁéáÂàóÂ∫îÁî®È¢úËâ≤ÔºåÊùÉÈáçÂàó‰øùÊåÅÁôΩËâ≤"""
                    styled_df = df.copy()
                    for col in df.columns:
                        if col in ['1d', '5d', '30d', '90d', 'since2024', 'since2025']:
                            styled_df[col] = df[col].apply(lambda x: 'color: red' if x < 0 else 'color: green' if x > 0 else '')
                        else:
                            styled_df[col] = ''  # ÊùÉÈáçÂàó‰øùÊåÅÁôΩËâ≤
                    return styled_df
                
                # ÂáÜÂ§áÊ†ºÂºèÂåñÂ≠óÂÖ∏
                format_dict = {}
                for col in returns_df_cum.columns:
                    if col == 'Weight(%)':
                        format_dict[col] = '{:.2f}%'
                    else:
                        format_dict[col] = '{:.2f}%'
                
                # ÊòæÁ§∫Ë°®Ê†º
                st.dataframe(returns_df_cum.style.format(format_dict).apply(color_returns_only, axis=None), use_container_width=True)
            
            # Ëá™2025Âπ¥ÂàùÁ¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØîÂõæ
            st.subheader("üìà Ëá™2025Âπ¥ÂàùÁ¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØî")
            
            # Ëé∑ÂèñÊâÄÊúâÂèØÁî®ÁöÑTicker
            available_tickers_2025 = list(filled_pri.columns)
            
            # ËÆ°ÁÆó30Â§©Êî∂ÁõäÁéáÊù•Ëé∑ÂèñTop 10 HoldingsÔºàÁî®‰∫éÈªòËÆ§ÈÄâÊã©Ôºâ
            cumulative_returns_30d_for_2025 = calculate_cumulative_returns(filled_pri, [30])
            if '30d' in cumulative_returns_30d_for_2025:
                top_10_holdings_2025 = cumulative_returns_30d_for_2025['30d'].nlargest(10).index.tolist()
            else:
                top_10_holdings_2025 = available_tickers_2025[:10]
            
            # ÂàõÂª∫Áã¨Á´ãÁöÑÂ§öÈÄâÂô®
            selected_tickers_2025 = st.multiselect(
                "ÈÄâÊã©Ë¶ÅÊòæÁ§∫ÁöÑËÇ°Á•®‰ª£Á†Å (Á¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØî):",
                options=available_tickers_2025,
                default=top_10_holdings_2025,
                help="ÈªòËÆ§ÊòæÁ§∫30Â§©Êî∂ÁõäÁéáÊúÄÈ´òÁöÑÂâç10‰∏™ÊåÅ‰ªì"
            )
            
            # ÁªòÂà∂Á¥ØËÆ°Êî∂ÁõäÁéáÂØπÊØîÂõæ
            if selected_tickers_2025:
                cum_returns_2025_fig = plot_cumulative_returns_since_2025(filled_pri, selected_tickers_2025)
                st.plotly_chart(cum_returns_2025_fig, use_container_width=True)
            else:
                st.warning("ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™ËÇ°Á•®‰ª£Á†Å")
                
        except Exception as e:
            st.error(f"ÊåÅ‰ªìÊî∂ÁõäÁéáÂàÜÊûêÈîôËØØ: {e}")
    
    # È£éÈô©ÂàÜÊûêÊ†áÁ≠æÈ°µ
    with tab5:
        st.header("‚ö†Ô∏è È£éÈô©ÂàÜÊûê")
        
        try:
            # ËÆ°ÁÆóÈ£éÈô©ÊåáÊ†á
            risk_metrics = calculate_risk_metrics(filled_pri, None)
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("È£éÈô©ÊåáÊ†á")
                
                # Ê≥¢Âä®Áéá
                volatility_avg = risk_metrics['volatility'].mean()
                st.metric(
                    "Âπ¥ÂåñÊ≥¢Âä®Áéá",
                    f"{volatility_avg:.2%}",
                    "",
                    delta_color="normal"
                )
                
                # ÊúÄÂ§ßÂõûÊí§
                max_dd = risk_metrics['max_drawdown'].min()
                st.metric(
                    "ÊúÄÂ§ßÂõûÊí§",
                    f"{max_dd:.2%}",
                    "",
                    delta_color="inverse"
                )
            
            with col2:
                # VaR
                var_avg = risk_metrics['var_95'].mean()
                st.metric(
                    "VaR (95%)",
                    f"{var_avg:.2%}",
                    "",
                    delta_color="inverse"
                )
                
                # SharpeÊØîÁéá
                sharpe_avg = risk_metrics['sharpe_ratio'].mean()
                st.metric(
                    "SharpeÊØîÁéá",
                    f"{sharpe_avg:.2f}",
                    "",
                    delta_color="normal"
                )
            
            # ÂõûÊí§ÂõæË°®
            st.subheader("ÂõûÊí§ÂàÜÊûê")
            daily_returns = filled_pri.pct_change().dropna()
            cumulative_returns = (1 + daily_returns).cumprod()
            rolling_max = cumulative_returns.expanding().max()
            drawdown = (cumulative_returns - rolling_max) / rolling_max
            
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=drawdown.index,
                y=drawdown.iloc[:, 0] * 100,
                mode='lines',
                fill='tonexty',
                name='Drawdown',
                line=dict(color='red')
            ))
            
            fig.update_layout(
                title="Fund Drawdown",
                xaxis_title="Date",
                yaxis_title="Drawdown (%)",
                height=400
            )
            
            st.plotly_chart(fig, use_container_width=True)
        except Exception as e:
            st.error(f"È£éÈô©ÂàÜÊûêÈîôËØØ: {e}")
    
    # Ë¥°ÁåÆÂ∫¶ÂàÜÊûêÊ†áÁ≠æÈ°µ
    with tab3:
        st.header("üéØ Ë¥°ÁåÆÂ∫¶ÂàÜÊûê")
        
        try:
            # ËÆ°ÁÆóË¥°ÁåÆÂ∫¶
            price_delta, price_impact, contribution = calculate_contribution(filled_pri, shares)
            
            if not price_delta.empty:
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("‰ª∑Ê†ºÂèòÂåñÂàÜÊûê")
                    
                    # ÊòæÁ§∫Ê∂®ÂπÖÊúÄÂ§ßÁöÑËÇ°Á•®ÔºàÂè™ÊòæÁ§∫Ê≠£Ê∂®ÂπÖÔºâ
                    positive_changes = price_delta[price_delta > 0]
                    if len(positive_changes) > 0:
                        top_gainers = positive_changes.nlargest(5) * 100
                        st.write("**üìà Ê∂®ÂπÖÊúÄÂ§ßÁöÑËÇ°Á•®:**")
                        for ticker, change in top_gainers.items():
                            st.markdown(f'<span class="positive">{ticker}: {change:.2f}%</span>', unsafe_allow_html=True)
                    else:
                        st.write("**üìà Ê∂®ÂπÖÊúÄÂ§ßÁöÑËÇ°Á•®:**")
                        st.write("‰ªäÊó•Êó†‰∏äÊ∂®ËÇ°Á•®")
                
                with col2:
                    st.subheader("Ë∑åÂπÖÊúÄÂ§ßÁöÑËÇ°Á•®")
                    
                    # ÊòæÁ§∫Ë∑åÂπÖÊúÄÂ§ßÁöÑËÇ°Á•®ÔºàÂè™ÊòæÁ§∫Ë¥üË∑åÂπÖÔºâ
                    negative_changes = price_delta[price_delta < 0]
                    if len(negative_changes) > 0:
                        top_losers = negative_changes.nsmallest(5) * 100
                        st.write("**üìâ Ë∑åÂπÖÊúÄÂ§ßÁöÑËÇ°Á•®:**")
                        for ticker, change in top_losers.items():
                            st.markdown(f'<span class="negative">{ticker}: {change:.2f}%</span>', unsafe_allow_html=True)
                    else:
                        st.write("**üìâ Ë∑åÂπÖÊúÄÂ§ßÁöÑËÇ°Á•®:**")
                        st.write("‰ªäÊó•Êó†‰∏ãË∑åËÇ°Á•®")
                
                # Ë¥°ÁåÆÂ∫¶ÂõæË°®
                st.subheader("ÊåÅ‰ªìË¥°ÁåÆÂ∫¶ÂàÜÊûê")
                fig = plot_contribution_analysis(contribution)
                st.plotly_chart(fig, use_container_width=True)
                
                # Ë¥°ÁåÆÂ∫¶Ë°®Ê†º
                st.subheader("Êò®Êó•ÂõûÊä•ËØ¶ÁªÜË¥°ÁåÆÂ∫¶Êï∞ÊçÆ")
                
                # ËÆ°ÁÆóÊåÅ‰ªìÊùÉÈáç
                if len(shares.columns) > 1:
                    shares_col = shares.iloc[:, 1]  # Á¨¨2Âàó
                else:
                    shares_col = shares.iloc[:, 0]  # Â¶ÇÊûúÂè™Êúâ1ÂàóÔºå‰ΩøÁî®Á¨¨1Âàó
                
                yesterday_value = filled_pri.iloc[1] * shares_col
                total_value = yesterday_value.sum()
                weight = yesterday_value / total_value * 100
                
                contribution_df = pd.DataFrame({
                    'Price_Change(%)': price_delta * 100,
                    'Weight(%)': weight,
                    'Price_Impact': price_impact,
                    'Contribution(%)': contribution * 100
                }).sort_values('Contribution(%)', ascending=False)
                
                # Á°Æ‰øùÊï∞ÊçÆÁ±ªÂûãÂÖºÂÆπ
                for col in contribution_df.columns:
                    contribution_df[col] = pd.to_numeric(contribution_df[col], errors='coerce')
                
                # Ê∑ªÂä†È¢úËâ≤Ê†∑Âºè - Âè™ÂØπ‰ª∑Ê†ºÂèòÂåñÂíåË¥°ÁåÆÂ∫¶ÂàóÂ∫îÁî®È¢úËâ≤
                def color_negative_red(val):
                    if isinstance(val, (int, float)):
                        if val < 0:
                            return 'color: red'
                        elif val > 0:
                            return 'color: green'
                    return ''
                
                def color_contribution_only(df):
                    """Âè™ÂØπ‰ª∑Ê†ºÂèòÂåñÂíåË¥°ÁåÆÂ∫¶ÂàóÂ∫îÁî®È¢úËâ≤ÔºåÊùÉÈáçÂàó‰øùÊåÅÁôΩËâ≤"""
                    styled_df = df.copy()
                    for col in df.columns:
                        if col in ['Price_Change(%)', 'Contribution(%)']:
                            styled_df[col] = df[col].apply(lambda x: 'color: red' if x < 0 else 'color: green' if x > 0 else '')
                        else:
                            styled_df[col] = ''  # ÊùÉÈáçÂàó‰øùÊåÅÁôΩËâ≤
                    return styled_df
                
                # Ê∑ªÂä†ÊêúÁ¥¢ÂíåËøáÊª§ÂäüËÉΩ
                col1, col2 = st.columns(2)
                
                with col1:
                    # ÊêúÁ¥¢ÁâπÂÆöËÇ°Á•®
                    search_term = st.text_input("üîç ÊêúÁ¥¢ËÇ°Á•®‰ª£Á†ÅÊàñÂêçÁß∞:", "")
                
                with col2:
                    # ËøáÊª§ÈÄâÈ°π
                    filter_option = st.selectbox(
                        "üìä ËøáÊª§ÈÄâÈ°π:",
                        ["ÂÖ®ÈÉ®ÊåÅ‰ªì", "Ê≠£Ë¥°ÁåÆ", "Ë¥üË¥°ÁåÆ", "ÊùÉÈáçÂâç10", "Ë¥°ÁåÆÂ∫¶Ââç10"]
                    )
                
                # Â∫îÁî®ËøáÊª§
                filtered_df = contribution_df.copy()
                
                if search_term:
                    filtered_df = filtered_df[filtered_df.index.str.contains(search_term, case=False, na=False)]
                
                if filter_option == "Ê≠£Ë¥°ÁåÆ":
                    filtered_df = filtered_df[filtered_df['Contribution(%)'] > 0]
                elif filter_option == "Ë¥üË¥°ÁåÆ":
                    filtered_df = filtered_df[filtered_df['Contribution(%)'] < 0]
                elif filter_option == "ÊùÉÈáçÂâç10":
                    filtered_df = filtered_df.nlargest(10, 'Weight(%)')
                elif filter_option == "Ë¥°ÁåÆÂ∫¶Ââç10":
                    filtered_df = filtered_df.nlargest(10, 'Contribution(%)')
                
                # ÊòæÁ§∫ËøáÊª§ÂêéÁöÑÊï∞ÊçÆ
                st.dataframe(filtered_df.style.format({
                    'Price_Change(%)': '{:.2f}%',
                    'Weight(%)': '{:.2f}%',
                    'Price_Impact': '{:.2f}',
                    'Contribution(%)': '{:.2f}%'
                }).apply(color_contribution_only, axis=None), use_container_width=True)
                
                # Ê∑ªÂä†ÁªüËÆ°‰ø°ÊÅØ
                st.subheader("üìä Ë¥°ÁåÆÂ∫¶ÁªüËÆ°")
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    positive_contrib = len(contribution_df[contribution_df['Contribution(%)'] > 0])
                    st.metric("Ê≠£Ë¥°ÁåÆÊåÅ‰ªìÊï∞", positive_contrib)
                
                with col2:
                    negative_contrib = len(contribution_df[contribution_df['Contribution(%)'] < 0])
                    st.metric("Ë¥üË¥°ÁåÆÊåÅ‰ªìÊï∞", negative_contrib)
                
                with col3:
                    total_contrib = len(contribution_df)
                    st.metric("ÊÄªÊåÅ‰ªìÊï∞", total_contrib)
                
                with col4:
                    avg_contrib = contribution_df['Contribution(%)'].mean()
                    st.metric("Âπ≥ÂùáË¥°ÁåÆÂ∫¶", f"{avg_contrib:.2f}%")
                
                # Ê∑ªÂä†ËØ¶ÁªÜÂàÜÊûêÊä•Âëä
                st.subheader("üìä ËØ¶ÁªÜÂàÜÊûêÊä•Âëä")
                
                # ËÆ°ÁÆóÊÄªÂΩ±Âìç
                total_impact = sum(price_impact)
                
                # ‰ª∑Ê†º‰∏ãÈôçÂàÜÊûê
                down_delta = price_delta.sort_values() * 100
                down_stocks = down_delta[down_delta <= -2]
                
                if len(down_stocks) > 0:
                    st.write("**üìâ ‰ª∑Ê†º‰∏ãÈôçÂπÖÂ∫¶ËæÉÂ§ßÁöÑËÇ°Á•® (>2%):**")
                    down_text = ""
                    for ticker, change in down_stocks.items():
                        # ËÇ°Á•®ÂêçÁß∞Êò†Â∞Ñ
                        display_name = ticker
                        if ticker == "KOSE:A000660":
                            display_name = "SK Hynix"
                        elif ticker == "TASE:NICE":
                            display_name = "NICE"
                        elif ticker == "TSE:3110":
                            display_name = "Nitto Boseki"
                        elif ticker == "TWSE:2330":
                            display_name = "TSM"
                        elif ticker == "TWSE:2454":
                            display_name = "MediaTek"
                        
                        down_text += f"{display_name}({change:.2f}%)Ôºå"
                    
                    st.markdown(f'<span class="negative">{down_text}‰ª∑Ê†º‰∏ãÈôçÂπÖÂ∫¶ËæÉÂ§ßÔºõ</span>', unsafe_allow_html=True)
                else:
                    st.write("**üìâ ‰ª∑Ê†º‰∏ãÈôçÂπÖÂ∫¶ËæÉÂ§ßÁöÑËÇ°Á•® (>2%):**")
                    st.write("‰ªäÊó•Êó†Ë∑åÂπÖË∂ÖËøá2%ÁöÑËÇ°Á•®")
                
                # ‰ª∑Ê†º‰∏äÊ∂®ÂàÜÊûê
                up_delta = price_delta.sort_values(ascending=False) * 100
                up_stocks = up_delta[up_delta >= 2]
                
                if len(up_stocks) > 0:
                    st.write("**üìà ‰ª∑Ê†º‰∏äÊ∂®ÂπÖÂ∫¶ËæÉÂ§ßÁöÑËÇ°Á•® (>2%):**")
                    up_text = ""
                    for ticker, change in up_stocks.items():
                        # ËÇ°Á•®ÂêçÁß∞Êò†Â∞Ñ
                        display_name = ticker
                        if ticker == "KOSE:A000660":
                            display_name = "SK Hynix"
                        elif ticker == "TASE:NICE":
                            display_name = "NICE"
                        elif ticker == "TSE:3110":
                            display_name = "Nitto Boseki"
                        elif ticker == "TWSE:2330":
                            display_name = "TSM"
                        elif ticker == "TWSE:2454":
                            display_name = "MediaTek"
                        
                        up_text += f"{display_name}({change:.2f}%)Ôºå"
                    
                    st.markdown(f'<span class="positive">{up_text}‰ª∑Ê†º‰∏äÊ∂®ÂπÖÂ∫¶ËæÉÂ§ßÔºõ</span>', unsafe_allow_html=True)
                else:
                    st.write("**üìà ‰ª∑Ê†º‰∏äÊ∂®ÂπÖÂ∫¶ËæÉÂ§ßÁöÑËÇ°Á•® (>2%):**")
                    st.write("‰ªäÊó•Êó†Ê∂®ÂπÖË∂ÖËøá2%ÁöÑËÇ°Á•®")
                
                # Ë¥°ÁåÆÂ∫¶ÂΩ±ÂìçÂàÜÊûê
                st.write("**üéØ ÂØπÂü∫ÈáëË°®Áé∞ÂΩ±ÂìçÊúÄÂ§ßÁöÑÊåÅ‰ªì:**")
                
                if total_impact > 0:
                    # ÊÄªÂΩ±Âìç‰∏∫Ê≠£ÔºåÊòæÁ§∫Ë¥°ÁåÆÊúÄÂ§ßÁöÑËÇ°Á•®
                    top_contributors = price_impact.sort_values(ascending=False)[:5]
                    impact_text = ""
                    for ticker, impact in top_contributors.items():
                        # ËÇ°Á•®ÂêçÁß∞Êò†Â∞Ñ
                        display_name = ticker
                        if ticker == "KOSE:A000660":
                            display_name = "SK Hynix"
                        elif ticker == "TASE:NICE":
                            display_name = "NICE"
                        elif ticker == "TSE:3110":
                            display_name = "Nitto Boseki"
                        elif ticker == "TWSE:2330":
                            display_name = "TSM"
                        elif ticker == "TWSE:2454":
                            display_name = "MediaTek"
                        
                        # Ëé∑ÂèñÂØπÂ∫îÁöÑ‰ª∑Ê†ºÂèòÂåñ
                        price_change = price_delta[ticker] * 100
                        impact_text += f"{display_name}({price_change:.2f}%)Ôºå"
                    
                    st.markdown(f'<span class="positive">{impact_text}‰∏∫ÂØπÊåáÊï∞Ë°®Áé∞‰∏äÊ∂®ÂΩ±ÂìçÊúÄÂ§ßÁöÑÂâç‰∫îÊåÅ‰ªìÔºõ</span>', unsafe_allow_html=True)
                else:
                    # ÊÄªÂΩ±Âìç‰∏∫Ë¥üÔºåÊòæÁ§∫ÊãñÁ¥ØÊúÄÂ§ßÁöÑËÇ°Á•®
                    bottom_contributors = price_impact.sort_values()[:5]
                    impact_text = ""
                    for ticker, impact in bottom_contributors.items():
                        # ËÇ°Á•®ÂêçÁß∞Êò†Â∞Ñ
                        display_name = ticker
                        if ticker == "KOSE:A000660":
                            display_name = "SK Hynix"
                        elif ticker == "TASE:NICE":
                            display_name = "NICE"
                        elif ticker == "TSE:3110":
                            display_name = "Nitto Boseki"
                        elif ticker == "TWSE:2330":
                            display_name = "TSM"
                        elif ticker == "TWSE:2454":
                            display_name = "MediaTek"
                        
                        # Ëé∑ÂèñÂØπÂ∫îÁöÑ‰ª∑Ê†ºÂèòÂåñ
                        price_change = price_delta[ticker] * 100
                        impact_text += f"{display_name}({price_change:.2f}%)Ôºå"
                    
                    st.markdown(f'<span class="negative">{impact_text}‰∏∫ÂØπÊåáÊï∞Ë°®Áé∞‰∏ãÈôçÂΩ±ÂìçÊúÄÂ§ßÁöÑÂâç‰∫îÊåÅ‰ªìÔºõ</span>', unsafe_allow_html=True)
                

            else:
                st.warning("Êó†Ê≥ïËÆ°ÁÆóË¥°ÁåÆÂ∫¶ÔºåËØ∑Ê£ÄÊü•Êï∞ÊçÆ")
        except Exception as e:
            st.error(f"Ë¥°ÁåÆÂ∫¶ÂàÜÊûêÈîôËØØ: {e}")
    
    # ÊåÅ‰ªìËØ¶ÊÉÖÊ†áÁ≠æÈ°µ
    with tab6:
        st.header("üìã ÊåÅ‰ªìËØ¶ÊÉÖ")
        
        if daily_holdings is not None:
            # ÊòæÁ§∫ÊåÅ‰ªìË°®Ê†º
            # Á°Æ‰øùÊï∞ÊçÆÁ±ªÂûãÂÖºÂÆπÔºåÈÅøÂÖçArrowÂ∫èÂàóÂåñÈóÆÈ¢ò
            display_holdings = daily_holdings.copy()
            
            # ËøáÊª§ÊéâtickerÊòØnanÁöÑË°å
            ticker_col = None
            possible_ticker_cols = ['Ticker', 'Symbol', 'ËÇ°Á•®‰ª£Á†Å', '‰ª£Á†Å']
            for col in display_holdings.columns:
                if any(ticker in str(col) for ticker in possible_ticker_cols):
                    ticker_col = col
                    break
            
            if ticker_col is not None:
                # ËøáÊª§ÊéâtickerÊòØnanÁöÑË°å
                display_holdings = display_holdings.dropna(subset=[ticker_col])
                # ËøáÊª§ÊéâtickerÊòØ'nan'Â≠óÁ¨¶‰∏≤ÁöÑË°å
                display_holdings = display_holdings[display_holdings[ticker_col] != 'nan']
            
            # ËøáÊª§ÊéâÊó•ÊúüÊó∂Èó¥ÂàóÔºàÂåÖÂê´Êó∂Èó¥Êà≥ÁöÑÂàóÔºâ
            date_columns = []
            for col in display_holdings.columns:
                if isinstance(col, str) and ('2025-' in col or '2024-' in col):
                    date_columns.append(col)
                elif hasattr(col, 'strftime'):  # Ê£ÄÊü•ÊòØÂê¶ÊòØdatetimeÂØπË±°
                    date_columns.append(col)
            
            # Âà†Èô§Êó•ÊúüÊó∂Èó¥Âàó
            if date_columns:
                display_holdings = display_holdings.drop(columns=date_columns)
            
            # Á°Æ‰øùÊâÄÊúâÂàóÈÉΩÊòØÂ≠óÁ¨¶‰∏≤Á±ªÂûã
            for col in display_holdings.columns:
                if display_holdings[col].dtype == 'object':
                    display_holdings[col] = display_holdings[col].astype(str)
            
            st.dataframe(display_holdings, use_container_width=True)
            
            # Â¶ÇÊûúÊúâË°å‰∏ö‰ø°ÊÅØÔºåÊòæÁ§∫Ë°å‰∏öÈÖçÁΩÆÂõæË°®
            if 'Sector' in daily_holdings.columns:
                st.subheader("Ë°å‰∏öÈÖçÁΩÆ")
                
                # ÂàõÂª∫‰∏§ÂàóÂ∏ÉÂ±Ä
                col1, col2 = st.columns(2)
                
                with col1:
                    # ÊåâÂÖ¨Âè∏Êï∞ÈáèÁöÑË°å‰∏öÈÖçÁΩÆ
                    sector_fig = plot_sector_allocation(daily_holdings)
                    if sector_fig:
                        st.plotly_chart(sector_fig, use_container_width=True)
                    else:
                        st.write("Êó†Ê≥ïÁîüÊàêÊåâÂÖ¨Âè∏Êï∞ÈáèÁöÑË°å‰∏öÈÖçÁΩÆÂõæ")
                
                with col2:
                    # ÊåâÂ∏ÇÂÄºÁöÑË°å‰∏öÈÖçÁΩÆ
                    market_cap_fig = plot_sector_market_cap(daily_holdings)
                    if market_cap_fig:
                        st.plotly_chart(market_cap_fig, use_container_width=True)
                    else:
                        st.write("Êó†Ê≥ïÁîüÊàêÊåâÂ∏ÇÂÄºÁöÑË°å‰∏öÈÖçÁΩÆÂõæ")
                
                # Ë°å‰∏öË¥°ÁåÆË°®Ê†º
                st.subheader("DTDË°å‰∏öË¥°ÁåÆ")
                contribution_df = calculate_sector_contribution(daily_holdings)
                if contribution_df is not None:
                    st.dataframe(contribution_df, use_container_width=True)
                else:
                    st.write("Êó†Ê≥ïÁîüÊàêË°å‰∏öË¥°ÁåÆË°®Ê†º")
        else:
            st.warning("Êó†Ê≥ïÂä†ËΩΩÊØèÊó•ÁõëÊéßÊåÅ‰ªìËØ¶ÊÉÖÊï∞ÊçÆ")
            st.write("ËØ∑Ê£ÄÊü• 'ciq reference/data/ÊØèÊó•Êï∞ÊçÆÁõëÊéß.xlsx' Êñá‰ª∂‰∏≠ÁöÑ 'holdings' Â∑•‰ΩúË°®ÊòØÂê¶Â≠òÂú®")
        

if __name__ == "__main__":
    main() 